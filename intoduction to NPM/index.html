What is NPM?
NPM stands for Node Package Manager

but it is not the only package manager. there are some other managers like yarn and pnpm but NPM is the most trusted and the Most used.

why do we need a package manager?

We need a package manager like NPM because modern software development is too complex and modular to build everything from scratch. A package manager solves several major problems:

üîß 1. Dependency Management
Problem: Manually downloading and tracking libraries is painful and error-prone.

Solution: A package manager automatically:

Downloads the right libraries (dependencies)

Installs the correct versions

Updates them when needed

üì¶ 2. Reusability of Code
Problem: Developers shouldn't keep reinventing the wheel.

Solution: With NPM, you can install common solutions like:

Web servers (express)

Authentication (passport)

Utility libraries (lodash, moment)

This saves time and ensures battle-tested code is reused.

üîÅ 3. Version Control
Problem: Code might break if dependencies change unexpectedly.

Solution: NPM uses package.json and package-lock.json to:

Lock specific versions of packages

Ensure everyone on a project uses the same setup

üë• 4. Collaboration & Scaling
Problem: In large teams or projects, managing code manually is chaotic.

Solution: With a package manager:

Everyone installs the same dependencies with a single command: npm install

New team members can set up quickly

üåê 5. Ecosystem Access
Problem: Without a central hub, finding reliable packages is hard.

Solution: NPM connects to a massive public registry of over 3 million packages. You can:

Discover tools

Learn from examples

Build faster

üõ†Ô∏è Real Life Analogy
A package manager is like an app store for developers. Instead of writing every app feature yourself, you:

Go to the app store (NPM registry)

Search what you need

Click "install" (run npm install)

Done.



NPM is:

A package manager ‚Äì It helps developers install, share, and manage third-party code libraries (called "packages" or "modules").

A registry ‚Äì It connects to a vast online database of JavaScript packages.

What does it have to do with Node.js?

Node.js is a JavaScript runtime that allows you to run JavaScript on the server (outside the browser).

NPM comes bundled with Node.js ‚Äì When you install Node.js, NPM is installed automatically.

NPM lets Node.js developers reuse existing code by installing packages like Express (for servers), React (for UIs), or Lodash (for utilities).


Anyone Can contribute to NPM packages.

and that's why we have to be careful when Installing Packages. whenever You are Installing an package go the NPM website and look at the Monthly Downloads and always double check your spelling for the Package.


So, lets Install and Use some Packages!.


step 1.) Initialize NPM (npm init)
npm init is a command that creates a new package.json file in your project folder.

what is a JSON:
A way to represent data in text form

Like a simplified version of a JavaScript object, but:

No functions

Only data (numbers, strings, arrays, objects)

‚öôÔ∏è Key Rules:

Data is in key-value pairs: "key": value

Strings use double quotes "

Objects use { }

Arrays use [ ]

Booleans are true or false

No comments allowed ‚ùå



Think of package.json like setting up the "identity card" for your project.

Why do we Use It?

To turn a folder into an NPM project

To start managing dependencies and scripts

To allow others (or yourself later) to run npm install and get everything working again\

fields:

"name"
The name of your project or package.

Must be lowercase, no spaces, and can include dashes.

If you publish to NPM, this is how others will find it.

"version"
Follows Semantic Versioning (semver): major.minor.patch

Example: "1.2.3"

1 = major: breaking changes

2 = minor: new features

3 = patch: bug fixes

 "description"
Short summary of what your app does.

Helpful for documentation and visibility on NPM.


 "main"
Entry point file when your package is imported by another.

For apps, it's usually the file Node should run to start the app.


"scripts"

Scripts let you create custom terminal commands for your project. These are shortcuts you can run with:

npm run <script-name>

üîπ Common Scripts
Script	What It Does
"start"	Default startup command (npm start)
"dev"	Often used to run with tools like nodemon
"build"	Used to compile code (e.g. Babel/Webpack)
"test"	Runs tests (npm test)


"dependencies"
Packages your project needs to run.

Added automatically when you run npm install <package>.


 "devDependencies"
Only needed for development (e.g., linters, test frameworks).

Not included when deploying to production.

"author" and "license"
Self-explanatory but important for open-source.

The -y flag means "yes to everything."

So instead of asking you a bunch of questions (like project name, version, description, etc.), it auto-generates a package.json file with default values instantly.



step 2.) Installing a package
When you install a package using NPM (Node Package Manager), you‚Äôre downloading code written by others so you can use it in your own Node.js project.

This code could be:

A library (like express for servers)

A tool (like nodemon for auto-restarting apps)

Something fun (like cowsay üêÆ)

npm install <package-name>
        or
npm i <package-name>

The package‚Äôs files are downloaded into a folder called node_modules/

package.json is updated to include it under "dependencies" (so others know what your project needs)

A package-lock.json file is created/updated to lock the exact versions for consistency

Package-lock.json file is like your project‚Äôs dependency receipt or snapshot.
It ensures everyone who installs your app gets the exact same versions of every package and its sub-packages.

Imagine two versions of the same package work differently. Without locking them, someone else might get a broken or outdated version.

 node_modules/
This is the physical folder where all installed packages (and their dependencies) are saved.


what about importing?
üîÑ CommonJS vs ES Modules
Style	        Also Called	         Import Syntax	        Export Syntax
CommonJS	require style	        const x = require('x')	module.exports = x
ES Modules	import/export style	import x from 'x'	export default x or export {}

common.js is built in. but to configure ES modules we have to put 
{
  "type": "module"
}
in our package.json




Now lets Understand Node Modules

üì¶ What are Node.js Modules?
Node.js modules are chunks of code that help you do specific tasks ‚Äî like reading files, working with paths, or creating servers.

There are 3 types:

1Ô∏è‚É£ Core Modules (Built-in Modules)
What? These are modules that come built into Node.js itself.

No installation needed! You can start using them right away.

They provide essential functionalities like file handling, path manipulation, networking, etc.

2Ô∏è‚É£ Local Modules (Your own files)
What? These are modules you create yourself inside your project.

You write reusable code in separate files, then import them where needed.

Helps keep your code clean and organized.

3Ô∏è‚É£ Third-party Modules (Installed via NPM)
What? These are modules published by others on npm registry.

You install them into your project with npm install <package-name>.

This lets you use tons of pre-built functionality without reinventing the wheel.

Examples:
express ‚Äî Web server framework

lodash ‚Äî Utility functions

cowsay ‚Äî Fun talking cow in terminal



what is fs?
The File System (fs) module lets you read, write, update, delete, and manipulate files and directories on your computer.

It‚Äôs super useful when you want your Node.js app to interact with files ‚Äî like saving data or reading configs.

common fs methods
| Method               | Description                                    | Example                                |
| -------------------- | ---------------------------------------------- | -------------------------------------- |
| `fs.readFile()`      | Read file contents asynchronously              | Reads text from a file                 |
| `fs.writeFile()`     | Write data to a file asynchronously            | Creates or overwrites a file           |
| `fs.appendFile()`    | Append data to an existing file asynchronously | Adds data to the end of a file         |
| `fs.existsSync()`    | Check if a file or directory exists            | Returns `true` or `false`              |



fs.writeFile()
What it does:
Writes data to a file asynchronously.

If the file doesn‚Äôt exist, it creates it.

If the file exists, it overwrites it.

You provide a callback for when the writing is done.

syntax:
fs.writeFile(path, data, options, callback)

path: file path (string)

data: content to write (string)

options: encoding, mode, flag (optional)

callback(err): function called when done



fs.readFile()
What it does:
Reads the contents of a file asynchronously (non-blocking).

You provide a callback that gets called after the file is read (or if there‚Äôs an error).

syntax:

fs.readFile(path, options, callback)

path: file path (string)

options: encoding or other flags (optional, often 'utf8' for text)

callback(err, data): function called when done



 fs.existsSync()
What it does:
Checks synchronously if a file or folder exists at the given path.

Returns true if it exists, false otherwise.

Useful to avoid errors before reading or writing files.

syntax:

fs.existsSync(path)


Path Module:
What is path?
It helps you work with file paths (like combining paths, getting filenames, extensions, directories) in a way that works consistently on Windows, macOS, Linux, etc.

| Method            | Description                                          | Example                                                                           |
| ----------------- | ---------------------------------------------------- | --------------------------------------------------------------------------------- |
| `path.basename()` | Returns the **filename** from a path                 | `path.basename('/foo/bar/baz.txt')` ‚Üí `'baz.txt'`                                 |
| `path.dirname()`  | Returns the **directory name**                       | `path.dirname('/foo/bar/baz.txt')` ‚Üí `'/foo/bar'`                                 |
| `path.extname()`  | Returns the **file extension**                       | `path.extname('index.html')` ‚Üí `'.html'`                                          |
| `path.join()`     | Joins multiple path segments safely                  | `path.join('foo', 'bar', 'baz.txt')` ‚Üí `'foo/bar/baz.txt'` or with `\` on Windows |
| `path.resolve()`  | Resolves a sequence of paths to an **absolute path** | `path.resolve('foo', 'bar')` ‚Üí `'/home/user/foo/bar'` (depends on cwd)            |


OS module
What is os?
Provides details about the operating system like platform, CPU info, memory stats, home directory, and more.

Super useful for writing system-aware or cross-platform apps.

const os = require('os');


| Method          | Description                                                    | Example Output                        |
| --------------- | -------------------------------------------------------------- | ------------------------------------- |
| `os.platform()` | Returns OS platform (`'win32'`, `'linux'`, `'darwin'` (macOS)) | `'win32'`                             |
| `os.arch()`     | CPU architecture (`'x64'`, `'arm'`, etc.)                      | `'x64'`                               |
| `os.cpus()`     | Returns an array with CPU info                                 | Array of CPU cores with speed info    |
| `os.homedir()`  | Path to current user‚Äôs home directory                          | `'/home/rehan'` or `C:\\Users\\Rehan` |
| `os.uptime()`   | System uptime in seconds                                       | `123456`                              |



