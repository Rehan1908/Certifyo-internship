<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Introduction to NPM</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <div class="container">
      <header>
        <h1>What is NPM?</h1>
      </header>
      
      <section>
        <p>NPM stands for Node Package Manager</p>
        <p>
          but it is not the only package manager. there are some other managers
          like yarn and pnpm but NPM is the most trusted and the Most used.
        </p>
      </section>
      
      <section>
        <h2>why do we need a package manager?</h2>
        <p>
          We need a package manager like NPM because modern software development is too complex and modular to build everything from scratch. A package manager solves several major problems:
        </p>
      </section>
      
      <section>
        <h3>üîß 1. Dependency Management</h3>
        <p><strong>Problem:</strong> Manually downloading and tracking libraries is painful and error-prone.</p>
        <p>
          <strong>Solution:</strong> A package manager automatically:
        </p>
        <ul>
          <li>Downloads the right libraries (dependencies)</li>
          <li>Installs the correct versions</li>
          <li>Updates them when needed</li>
        </ul>
      </section>
      
      <section>
        <h3>üì¶ 2. Reusability of Code</h3>
        <p><strong>Problem:</strong> Developers shouldn't keep reinventing the wheel.</p>
        <p>
          <strong>Solution:</strong> With NPM, you can install common solutions like:
        </p>
        <ul>
          <li>Web servers (express)</li>
          <li>Authentication (passport)</li>
          <li>Utility libraries (lodash, moment)</li>
        </ul>
        <p>This saves time and ensures battle-tested code is reused.</p>
      </section>
      
      <section>
        <h3>üîÅ 3. Version Control</h3>
        <p><strong>Problem:</strong> Code might break if dependencies change unexpectedly.</p>
        <p>
          <strong>Solution:</strong> NPM uses <code>package.json</code> and <code>package-lock.json</code> to:
        </p>
        <ul>
          <li>Lock specific versions of packages</li>
          <li>Ensure everyone on a project uses the same setup</li>
        </ul>
      </section>
      
      <section>
        <h3>üë• 4. Collaboration &amp; Scaling</h3>
        <p><strong>Problem:</strong> In large teams or projects, managing code manually is chaotic.</p>
        <p>
          <strong>Solution:</strong> With a package manager:
        </p>
        <ul>
          <li>Everyone installs the same dependencies with a single command: <code>npm install</code></li>
          <li>New team members can set up quickly</li>
        </ul>
      </section>
      
      <section>
        <h3>üåê 5. Ecosystem Access</h3>
        <p><strong>Problem:</strong> Without a central hub, finding reliable packages is hard.</p>
        <p>
          <strong>Solution:</strong> NPM connects to a massive public registry of over 3 million packages. You can:
        </p>
        <ul>
          <li>Discover tools</li>
          <li>Learn from examples</li>
          <li>Build faster</li>
        </ul>
      </section>
      
      <section>
        <h2>üõ†Ô∏è Real Life Analogy</h2>
        <p>
          A package manager is like an app store for developers. Instead of writing every app feature yourself, you:
        </p>
        <ol>
          <li>Go to the app store (NPM registry)</li>
          <li>Search what you need</li>
          <li>Click "install" (<code>npm install</code>)</li>
          <li>Done.</li>
        </ol>
      </section>
      
      <section>
        <h2>NPM is:</h2>
        <ul>
          <li>
            A package manager ‚Äì It helps developers install, share, and manage third-party code libraries (called "packages" or "modules").
          </li>
          <li>
            A registry ‚Äì It connects to a vast online database of JavaScript packages.
          </li>
        </ul>
        <p>
          What does it have to do with Node.js?
        </p>
        <p>
          Node.js is a JavaScript runtime that allows you to run JavaScript on the server (outside the browser).
        </p>
        <p>
          NPM comes bundled with Node.js ‚Äì When you install Node.js, NPM is installed automatically.
        </p>
        <p>
          NPM lets Node.js developers reuse existing code by installing packages like Express (for servers), React (for UIs), or Lodash (for utilities).
        </p>
        <p>
          Anyone Can contribute to NPM packages.
        </p>
        <p>
          and that's why we have to be careful when Installing Packages. whenever You are Installing an package go the NPM website and look at the Weekly Downloads and always double check your spelling for the Package.
        </p>
      </section>
      
      <section>
        <h2>So, lets Install and Use some Packages!</h2>
        <section>
          <h3>step 1.) Initialize NPM (<code>npm init</code>)</h3>
          <p>
            <code>npm init</code> is a command that creates a new <code>package.json</code> file in your project folder.
          </p>
          <p>what is a JSON:</p>
          <p>A way to represent data in text form</p>
          <p>Like a simplified version of a JavaScript object, but:</p>
          <ul>
            <li>No functions</li>
            <li>Only data (numbers, strings, arrays, objects)</li>
          </ul>
          <p>‚öôÔ∏è Key Rules:</p>
          <ul>
            <li>Data is in key-value pairs: <code>"key": value</code></li>
            <li>Strings use double quotes <code>"</code></li>
            <li>Objects use <code>{ }</code></li>
            <li>Arrays use <code>[ ]</code></li>
            <li>Booleans are <code>true</code> or <code>false</code></li>
            <li>No comments allowed ‚ùå</li>
          </ul>
          <p>
            Think of <code>package.json</code> like setting up the "identity card" for your project.
          </p>
          <!-- New Package.json Fields Section added here -->
          <section>
            <h3>package.json Fields</h3>
            <dl>
              <dt><strong>"name"</strong></dt>
              <dd>
                The name of your project or package.<br>
                Must be lowercase, no spaces, and can include dashes.<br>
                If you publish to NPM, this is how others will find it.
              </dd>
              <dt><strong>"version"</strong></dt>
              <dd>
                Follows Semantic Versioning (semver): major.minor.patch<br>
                Example: "1.2.3"<br>
                1 = major: breaking changes<br>
                2 = minor: new features<br>
                3 = patch: bug fixes
              </dd>
              <dt><strong>"description"</strong></dt>
              <dd>
                Short summary of what your app does.<br>
                Helpful for documentation and visibility on NPM.
              </dd>
              <dt><strong>"main"</strong></dt>
              <dd>
                Entry point file when your package is imported by another.<br>
                For apps, it's usually the file Node should run to start the app.
              </dd>
              <dt><strong>"scripts"</strong></dt>
              <dd>
                Scripts let you create custom terminal commands for your project. These are shortcuts you can run with:<br>
                <code>npm run &lt;script-name&gt;</code><br>
                <strong>üîπ Common Scripts</strong>
                <ul>
                  <li><strong>"start"</strong> &ndash; Default startup command (<code>npm start</code>)</li>
                  <li><strong>"dev"</strong> &ndash; Often used to run with tools like nodemon</li>
                  <li><strong>"build"</strong> &ndash; Used to compile code (e.g. Babel/Webpack)</li>
                  <li><strong>"test"</strong> &ndash; Runs tests (<code>npm test</code>)</li>
                </ul>
              </dd>
              <dt><strong>"dependencies"</strong></dt>
              <dd>
                Packages your project needs to run.<br>
                Added automatically when you run <code>npm install &lt;package&gt;</code>.
              </dd>
              <dt><strong>"devDependencies"</strong></dt>
              <dd>
                Only needed for development (e.g., linters, test frameworks).<br>
                Not included when deploying to production.
              </dd>
              <dt><strong>"author" and "license"</strong></dt>
              <dd>
                Self-explanatory but important for open-source.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3>step 2.) Installing a package</h3>
          <p>
            When you install a package using NPM (Node Package Manager), you‚Äôre downloading code written by others so you can use it in your own Node.js project.
          </p>
          <p>This code could be:</p>
          <ul>
            <li>A library (like express for servers)</li>
            <li>A tool (like nodemon for auto-restarting apps)</li>
            <li>Something fun (like cowsay üêÆ)</li>
          </ul>
          <p>
            <code>npm install &lt;package-name&gt; or npm i &lt;package-name&gt;</code>
          </p>
          <p>
            The package‚Äôs files are downloaded into a folder called <code>node_modules/</code>
          </p>
          <p>
            <code>package.json</code> is updated to include it under "dependencies" (so others know what your project needs)
          </p>
          <p>
            A <code>package-lock.json</code> file is created/updated to lock the exact versions for consistency
          </p>
          <p>
            <code>Package-lock.json</code> file is like your project‚Äôs dependency receipt or snapshot. It ensures everyone who installs your app gets the exact same versions of every package and its sub-packages.
          </p>
          <p>
            Imagine two versions of the same package work differently. Without locking them, someone else might get a broken or outdated version.
          </p>
          <p>
            <code>node_modules/</code> This is the physical folder where all installed packages (and their dependencies) are saved.
          </p>
        </section>
      </section>
      
      <section>
        <h2>what about importing?</h2>
        <p>üîÑ CommonJS vs ES Modules</p>
        <table>
          <thead>
            <tr>
              <th>Style</th>
              <th>Also Called</th>
              <th>Import Syntax</th>
              <th>Export Syntax</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>CommonJS</td>
              <td>require style</td>
              <td><code>const x = require('x')</code></td>
              <td><code>module.exports = x</code></td>
            </tr>
            <tr>
              <td>ES Modules</td>
              <td>import/export style</td>
              <td><code>import x from 'x'</code></td>
              <td><code>export default x</code> or <code>export {}</code></td>
            </tr>
          </tbody>
        </table>
        <p>
          common.js is built in. but to configure ES modules we have to put the following in our <code>package.json</code>:
        </p>
        <pre>{
  "type": "module"
}</pre>
      </section>
      
      <section>
        <h2>Now lets Understand Node Modules</h2>
        <p>üì¶ What are Node.js Modules?</p>
        <p>
          Node.js modules are chunks of code that help you do specific tasks ‚Äî like reading files, working with paths, or creating servers.
        </p>
        <p>There are 3 types:</p>
        <ol>
          <li>
            <strong>Core Modules (Built-in Modules):</strong> These are modules that come built into Node.js itself. No installation needed! You can start using them right away. They provide essential functionalities like file handling, path manipulation, networking, etc.
          </li>
          <li>
            <strong>Local Modules (Your own files):</strong> These are modules you create yourself inside your project. You write reusable code in separate files, then import them where needed. Helps keep your code clean and organized.
          </li>
          <li>
            <strong>Third-party Modules (Installed via NPM):</strong> These are modules published by others on npm registry. You install them into your project with <code>npm install &lt;package-name&gt;</code>. This lets you use tons of pre-built functionality without reinventing the wheel.
            <ul>
              <li>Examples:</li>
              <li>express ‚Äî Web server framework</li>
              <li>lodash ‚Äî Utility functions</li>
              <li>cowsay ‚Äî Fun talking cow in terminal</li>
            </ul>
          </li>
        </ol>
      </section>
      
      <section>
        <h2>what is fs?</h2>
        <p>
          The File System (<code>fs</code>) module lets you read, write, update, delete, and manipulate files and directories on your computer.
        </p>
        <p>
          It‚Äôs super useful when you want your Node.js app to interact with files ‚Äî like saving data or reading configs.
        </p>
        <h3>common fs methods</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Description</th>
              <th>Example</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>fs.readFile()</code></td>
              <td>Read file contents asynchronously</td>
              <td>Reads text from a file</td>
            </tr>
            <tr>
              <td><code>fs.writeFile()</code></td>
              <td>Write data to a file asynchronously</td>
              <td>Creates or overwrites a file</td>
            </tr>
            <tr>
              <td><code>fs.appendFile()</code></td>
              <td>Append data to an existing file asynchronously</td>
              <td>Adds data to the end of a file</td>
            </tr>
            <tr>
              <td><code>fs.existsSync()</code></td>
              <td>Check if a file or directory exists</td>
              <td>Returns <code>true</code> or <code>false</code></td>
            </tr>
          </tbody>
        </table>
      </section>
      
      <section>
        <h2>fs.writeFile()</h2>
        <p>What it does:</p>
        <p>
          Writes data to a file asynchronously. If the file doesn‚Äôt exist, it creates it. If the file exists, it overwrites it. You provide a callback for when the writing is done.
        </p>
        <p><strong>syntax:</strong></p>
        <pre>fs.writeFile(path, data, options, callback)</pre>
        <ul>
          <li>path: file path (string)</li>
          <li>data: content to write (string)</li>
          <li>options: encoding, mode, flag (optional)</li>
          <li>callback(err): function called when done</li>
        </ul>
      </section>
      
      <section>
        <h2>fs.readFile()</h2>
        <p>What it does:</p>
        <p>
          Reads the contents of a file asynchronously (non-blocking). You provide a callback that gets called after the file is read (or if there‚Äôs an error).
        </p>
        <p><strong>syntax:</strong></p>
        <pre>fs.readFile(path, options, callback)</pre>
        <ul>
          <li>path: file path (string)</li>
          <li>options: encoding or other flags (optional, often 'utf8' for text)</li>
          <li>callback(err, data): function called when done</li>
        </ul>
      </section>
      
      <section>
        <h2>fs.existsSync()</h2>
        <p>What it does:</p>
        <p>
          Checks synchronously if a file or folder exists at the given path. Returns <code>true</code> if it exists, <code>false</code> otherwise. Useful to avoid errors before reading or writing files.
        </p>
        <p><strong>syntax:</strong></p>
        <pre>fs.existsSync(path)</pre>
      </section>
      
      <section>
        <h2>Path Module:</h2>
        <p>What is <code>path</code>?</p>
        <p>
          It helps you work with file paths (like combining paths, getting filenames, extensions, directories) in a way that works consistently on Windows, macOS, Linux, etc.
        </p>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Description</th>
              <th>Example</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>path.basename()</code></td>
              <td>Returns the <strong>filename</strong> from a path</td>
              <td><code>path.basename('/foo/bar/baz.txt')</code> ‚Üí <code>'baz.txt'</code></td>
            </tr>
            <tr>
              <td><code>path.dirname()</code></td>
              <td>Returns the <strong>directory name</strong> from a path</td>
              <td><code>path.dirname('/foo/bar/baz.txt')</code> ‚Üí <code>'/foo/bar'</code></td>
            </tr>
            <tr>
              <td><code>path.extname()</code></td>
              <td>Returns the <strong>file extension</strong></td>
              <td><code>path.extname('index.html')</code> ‚Üí <code>'.html'</code></td>
            </tr>
            <tr>
              <td><code>path.join()</code></td>
              <td>Joins multiple path segments safely</td>
              <td><code>path.join('foo', 'bar', 'baz.txt')</code> ‚Üí <code>'foo/bar/baz.txt'</code></td>
            </tr>
            <tr>
              <td><code>path.resolve()</code></td>
              <td>Resolves a sequence of paths to an <strong>absolute path</strong></td>
              <td><code>path.resolve('foo', 'bar')</code> ‚Üí <code>'/home/user/foo/bar'</code></td>
            </tr>
          </tbody>
        </table>
      </section>
      
      <section>
        <h2>OS module</h2>
        <p>What is <code>os</code>?</p>
        <p>
          Provides details about the operating system like platform, CPU info, memory stats, home directory, and more. Super useful for writing system-aware or cross-platform apps.
        </p>
        <p><code>const os = require('os');</code></p>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Description</th>
              <th>Example Output</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>os.platform()</code></td>
              <td>Returns OS platform (<code>'win32'</code>, <code>'linux'</code>, <code>'darwin'</code> (macOS))</td>
              <td><code>'win32'</code></td>
            </tr>
            <tr>
              <td><code>os.arch()</code></td>
              <td>CPU architecture (<code>'x64'</code>, <code>'arm'</code>, etc.)</td>
              <td><code>'x64'</code></td>
            </tr>
            <tr>
              <td><code>os.cpus()</code></td>
              <td>Returns an array with CPU info</td>
              <td>Array of CPU cores with speed info</td>
            </tr>
            <tr>
              <td><code>os.homedir()</code></td>
              <td>Path to current user‚Äôs home directory</td>
              <td><code>'/home/rehan'</code> or <code>'C:\Users\Rehan'</code></td>
            </tr>
            <tr>
              <td><code>os.uptime()</code></td>
              <td>System uptime in seconds</td>
              <td><code>'123456'</code></td>
            </tr>
          </tbody>
        </table>
      </section>
      
    </div>
  </body>
</html>



