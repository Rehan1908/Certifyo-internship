<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Authentication with bcrypt.js</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
    </script>
</head>
<body>
    <header>
        <div class="container">
            <h1>User Registration and Login</h1>
            <p class="subtitle">Authentication with bcrypt.js and JWT</p>
        </div>
    </header>

    <main class="container">
        <section class="intro">
            <p>A user registration system ties together a few moving parts—Express for handling requests, bcrypt for safely storing passwords, and JWT for issuing tokens to authenticated users.</p>
        </section>

        <div class="divider"></div>

        <section id="components">
            <h2>1. Key Components and Roles</h2>

            <div class="component-card">
                <h3>Express (Web Framework):</h3>
                <ul>
                    <li>Acts as the HTTP server.</li>
                    <li>Exposes routes like <code>/register</code> and <code>/login</code>.</li>
                    <li>Parses JSON bodies and sends JSON responses.</li>
                </ul>
            </div>

            <div class="component-card">
                <h3>Database (e.g., MongoDB, PostgreSQL, etc.):</h3>
                <ul>
                    <li>Stores user records: at a minimum, an email (or username) and a hashed password.</li>
                    <li>You'll also probably keep a unique user ID (automatically generated) and maybe timestamps (<code>createdAt</code>, <code>updatedAt</code>).</li>
                </ul>
            </div>

            <div class="component-card">
                <h3>bcrypt (Password Hashing Library):</h3>
                <ul>
                    <li>Takes a plain-text password and produces a salted hash.</li>
                    <li>When a user logs in, you compare the incoming password with the stored hash—bcrypt's algorithms handle salt and timing considerations.</li>
                </ul>
            </div>

            <div class="component-card">
                <h3>jsonwebtoken (JWT Library):</h3>
                <ul>
                    <li>Creates a signed token once a user is authenticated.</li>
                    <li>That token is sent back to the client, which includes it in the <code>Authorization</code> header for protected routes.</li>
                </ul>
            </div>

            <div class="component-card">
                <h3>Environment Variables & Configuration:</h3>
                <ul>
                    <li>Store sensitive values in a <code>.env</code> file (or a secrets manager): e.g., <code>JWT_SECRET</code> and the bcrypt "salt rounds" setting.</li>
                    <li>Never hard-code secrets in your source.</li>
                </ul>
            </div>
        </section>

        <section id="registration-flow">
            <h2>2. The Registration Flow (Conceptual)</h2>

            <div class="flow-step">
                <h3>1. Client Sends Registration Data</h3>
                <ul>
                    <li>The user fills out a signup form (e.g., email + password).</li>
                    <li>The client (browser or app) sends a POST request to something like <code>POST /api/auth/register</code> with a JSON body:</li>
                </ul>
                <pre><code class="language-json">{
  "email": "user@example.com",
  "password": "mypassword123"
}</code></pre>
            </div>

            <div class="flow-step">
                <h3>2. Express Receives and Validates Input</h3>
                <ul>
                    <li>Express middleware checks:
                        <ul>
                            <li><strong>Presence and format:</strong> Is the email field provided and syntactically valid?</li>
                            <li><strong>Password rules:</strong> Minimum length, complexity, etc.</li>
                        </ul>
                    </li>
                    <li>If validation fails, respond with a 400 Bad Request (e.g., <code>{ error: "Password must be at least 8 characters." }</code>).</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>3. Check for Existing Account</h3>
                <ul>
                    <li>Query the database to see if a user with that email already exists.</li>
                    <li>If yes, return a 400 (or 409 Conflict) with a message like "Email already in use."</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>4. Hash the Password with bcrypt</h3>
                <ul>
                    <li>Generate a salt and hash the plain-text password.</li>
                    <li>Example parameters (conceptually):
                        <ul>
                            <li><strong>Salt rounds (cost factor):</strong> How many internal hashing iterations, often a number like 10 or 12.</li>
                        </ul>
                    </li>
                    <li>bcrypt outputs something that looks like <code>$2a$10$...</code>—you store that entire string in the database.</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>5. Save the New User to the Database</h3>
                <ul>
                    <li>Create a new User record with fields like:
                        <ul>
                            <li><code>email: "user@example.com"</code></li>
                            <li><code>passwordHash: "$2a$10$..."</code></li>
                            <li><code>createdAt: &lt;timestamp&gt;</code></li>
                        </ul>
                    </li>
                    <li>The database returns a unique ID (e.g., a MongoDB <code>_id</code> or SQL <code>id</code>).</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>6. Optionally Issue a JWT on Registration (or Require Login First)</h3>
                <ul>
                    <li>Some apps immediately log the user in after sign-up, issuing a token in the response.</li>
                    <li>Others force the user to "log in" after registering, to confirm credentials again.</li>
                    <li>If issuing the JWT right away:
                        <ol>
                            <li>Build a payload, typically containing at least <code>sub: &lt;userId&gt;</code> and maybe <code>email</code> or <code>roles</code>.</li>
                            <li>Sign it with your <code>JWT_SECRET</code> and set an expiration (e.g., 1 hour).</li>
                            <li>Return a JSON response <code>{ token: "&lt;JWT_STRING&gt;" }</code> so the client can store it (in memory, or local storage/cookie).</li>
                        </ol>
                    </li>
                </ul>
            </div>
        </section>

        <section id="login-flow">
            <h2>3. The Login Flow (Conceptual)</h2>

            <div class="flow-step">
                <h3>1. Client Sends Login Data</h3>
                <ul>
                    <li>Similar to registration, but usually only email and password:</li>
                </ul>
                <pre><code class="language-json">{
  "email": "user@example.com",
  "password": "mypassword123"
}</code></pre>
            </div>

            <div class="flow-step">
                <h3>2. Express Validates Inputs</h3>
                <ul>
                    <li>Confirm that email and password fields are present.</li>
                    <li>If missing/invalid, return 400 with a clear message.</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>3. Fetch User from Database by Email</h3>
                <ul>
                    <li>If no user found, respond with 401 Unauthorized (e.g., <code>{ error: "Invalid credentials." }</code>).</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>4. Compare the Plain-Text Password to the Stored Hash</h3>
                <ul>
                    <li>Use <code>bcrypt.compare(plainTextPassword, storedHash)</code> under the hood.</li>
                    <li>If comparison fails, respond with 401 Unauthorized again.</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>5. Issue a JWT upon Successful Login</h3>
                <ul>
                    <li>Construct a payload (e.g., <code>{ sub: userId, email: userEmail }</code>).</li>
                    <li>Sign it with <code>jsonwebtoken</code>, including an <code>expiresIn</code> value (e.g., "1h").</li>
                    <li>Return the token in JSON: <code>{ token: "&lt;JWT_STRING&gt;" }</code>.</li>
                </ul>
            </div>
        </section>

        <section id="protecting-routes">
            <h2>4. Securing Protected Routes with JWT</h2>

            <div class="flow-step">
                <h3>1. Client Stores the JWT</h3>
                <ul>
                    <li>Most SPAs store the token in memory or a secure HTTP-only cookie.</li>
                    <li>Mobile apps might store it in secure storage. The point is: send it back automatically in subsequent requests.</li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>2. Client Sends JWT on Requests</h3>
                <ul>
                    <li>For every request to a protected resource, the client includes an <code>Authorization</code> header:</li>
                </ul>
                <pre><code class="language-text">Authorization: Bearer &lt;JWT_STRING&gt;</code></pre>
            </div>

            <div class="flow-step">
                <h3>3. JWT Validation Middleware</h3>
                <ul>
                    <li>In Express, you write (or import) a middleware function that:
                        <ol>
                            <li>Reads <code>req.headers.authorization</code>.</li>
                            <li>Confirms it begins with <code>Bearer </code>.</li>
                            <li>Extracts the token portion and calls <code>jwt.verify(token, JWT_SECRET)</code>.</li>
                            <li>If verification passes, attaches the decoded payload (e.g., <code>{ sub: userId, email: userEmail, iat: ..., exp: ... }</code>) to something like <code>req.user</code>.</li>
                            <li>If it fails (invalid signature or expired), responds with 401 Unauthorized.</li>
                        </ol>
                    </li>
                </ul>
            </div>

            <div class="flow-step">
                <h3>4. Protected Route Handlers Rely on <code>req.user</code></h3>
                <ul>
                    <li>Once the middleware has run, your route handler can read <code>req.user.sub</code> (the user ID) or other claims (like <code>roles</code>) to decide whether to allow or reject the request.</li>
                    <li>For example, a route <code>/api/profile</code> might fetch the user's record from the database using <code>req.user.sub</code> and return profile data; or a route <code>/api/admin/dashboard</code> might check <code>req.user.role === "admin"</code> before proceeding.</li>
                </ul>
            </div>
        </section>

        <section id="why-together">
            <h2>5. Why bcrypt + JWT Together?</h2>

            <div class="benefit-card">
                <h3>bcrypt</h3>
                <ul>
                    <li>Protects passwords at rest. Even if your database leaks, attackers can't easily reverse a bcrypt hash (because of salting and the work factor).</li>
                    <li>You never store or log plain-text passwords—only the hash.</li>
                </ul>
            </div>

            <div class="benefit-card">
                <h3>JWT</h3>
                <ul>
                    <li>After a user proves who they are (by matching their password hash), you hand them a token they can present on future requests.</li>
                    <li>The server doesn't need to hit the database on every single request to check "Is this user logged in?"—it just verifies the token's signature and expiration.</li>
                    <li>JWTs carry a payload (claims) that can include roles, permissions, or any other metadata. Downstream services can read those claims without additional lookups.</li>
                </ul>
            </div>
        </section>

        <section id="considerations">
            <h2>6. Important Considerations</h2>

            <div class="consideration">
                <h3>Keep Secrets Secret</h3>
                <ul>
                    <li>The <code>JWT_SECRET</code> must never be committed to version control. Store it in environment variables or a secrets manager.</li>
                    <li>The bcrypt "salt rounds" configuration (e.g., <code>saltRounds = 10</code>) can also live in an environment variable or config file, but it's not a secret—just something you tune for performance vs. security.</li>
                </ul>
            </div>

            <div class="consideration">
                <h3>Token Expiration & Refresh</h3>
                <ul>
                    <li>JWTs should be short-lived (e.g., 15 minutes or 1 hour). If you make them long-lived, a stolen token remains valid for too long.</li>
                    <li>Implement a refresh-token mechanism if you want seamless re-authentication without forcing the user to log in again when the JWT expires.</li>
                </ul>
            </div>

            <div class="consideration">
                <h3>Secure Storage on the Client</h3>
                <ul>
                    <li>In a browser, avoid storing JWTs in localStorage (because of XSS risks). Instead, consider an HTTP-only cookie with <code>Secure</code> and <code>SameSite</code> flags, or store it in memory and refresh frequently.</li>
                    <li>In native mobile apps, use secure storage (Keychain on iOS, Keystore on Android).</li>
                </ul>
            </div>

            <div class="consideration">
                <h3>Email Verification (Optional but Recommended)</h3>
                <ul>
                    <li>After registration, you can send the user a one-time link or code via email. Only once they verify that link does their account become "active."</li>
                    <li>Prevents fake/spam registrations and ensures you have a valid email for password resets.</li>
                </ul>
            </div>

            <div class="consideration">
                <h3>Password-Reset Flow</h3>
                <ul>
                    <li>Allow users to request a password reset by sending a separate short-lived token (also signed with JWT or a random UUID stored in DB).</li>
                    <li>When they click the link, you verify that token, allow them to set a new password (bcrypt-hash it), then invalidate any previous tokens or sessions if necessary.</li>
                </ul>
            </div>

            <div class="consideration">
                <h3>Role-Based Access Control (RBAC)</h3>
                <ul>
                    <li>Store a <code>role</code> or <code>permissions</code> claim in the JWT payload (e.g., <code>"role": "user"</code> vs. <code>"role": "admin"</code>).</li>
                    <li>Your "authorization" middleware can read <code>req.user.role</code> and decide which routes a user may access.</li>
                </ul>
            </div>
        </section>

        <div class="summary-box">
            <h3>In a Nutshell</h3>
            <ol>
                <li><strong>User Registers:</strong>
                    <ul>
                        <li>Receive email + password, validate, hash password with bcrypt, store in DB.</li>
                        <li>Optionally issue a JWT immediately or wait until first login.</li>
                    </ul>
                </li>
                <li><strong>User Logs In:</strong>
                    <ul>
                        <li>Receive email + password, fetch user by email, compare with bcrypt, then issue a JWT if valid.</li>
                    </ul>
                </li>
                <li><strong>User Stores & Sends JWT:</strong>
                    <ul>
                        <li>Client stores the JWT safely, and on every future request to a protected endpoint, includes it in an <code>Authorization: Bearer &lt;token&gt;</code> header.</li>
                    </ul>
                </li>
                <li><strong>Server Validates JWT</strong>
                    <ul>
                        <li>A middleware verifies the token's signature (using <code>JWT_SECRET</code>) and checks expiration.</li>
                        <li>It then populates <code>req.user</code> with user identity/claims for downstream handlers.</li>
                    </ul>
                </li>
                <li><strong>Protected Routes Check <code>req.user</code></strong>
                    <ul>
                        <li>Route handlers or additional authorization middleware can enforce role checks or user-specific access based on the decoded JWT claims.</li>
                    </ul>
                </li>
            </ol>
            <p>This high-level design ensures passwords are never stored in plaintext, user sessions are stateless (via JWTs), and you can easily scale your Express app because each server only needs the secret key to verify tokens—no shared session store required.</p>
        </div>

        <div class="divider section-divider"></div>

        <section id="bcrypt-overview">
            <h2>Understanding bcrypt</h2>

            <p class="intro-text">
                bcrypt is a popular password-hashing function designed specifically to protect user passwords in databases. Rather than storing plain-text passwords (which is very risky), you hash passwords with bcrypt so that even if your database is compromised, attackers can't easily recover the original passwords. Here's an overview of how bcrypt works and why you'd use it.
            </p>

            <section id="why-hash">
                <h3>1. Why Hash Passwords at All?</h3>

                <div class="info-card">
                    <h4>One-Way Function</h4>
                    <ul>
                        <li>A hash function takes input (like "mypassword123") and produces a fixed-length string (the "hash").</li>
                        <li>Ideally, you can't reverse the hash to get the original password.</li>
                    </ul>
                </div>

                <div class="info-card">
                    <h4>Preventing Rainbow-Table Attacks</h4>
                    <ul>
                        <li>If you simply applied a fast hash (like SHA-256) to every password, attackers could precompute hashes of common passwords ("123456", "password", etc.) and look up matches quickly.</li>
                        <li>That's why you need <strong>salt</strong> and a deliberately slow algorithm—bcrypt does both.</li>
                    </ul>
                </div>
            </section>

            <section id="bcrypt-advantages">
                <h3>2. What Sets bcrypt Apart?</h3>

                <div class="info-card">
                    <h4>Built-In Salt</h4>
                    <ul>
                        <li>Every time you hash a password with bcrypt, it automatically generates a random "salt" (a random string of bits).</li>
                        <li>The salt is mixed into the hashing process, so even two users with the same password will end up with completely different hashes.</li>
                    </ul>
                </div>

                <div class="info-card">
                    <h4>Cost Factor (Work Factor / Salt Rounds)</h4>
                    <ul>
                        <li>bcrypt is deliberately slow: it runs a configurable number of internal iterations (the "salt rounds" or "cost").</li>
                        <li>The higher the cost, the longer it takes to compute a hash. That's good for security (makes brute-forcing much slower), but you must choose a cost that's not too slow for your server.</li>
                    </ul>
                </div>

                <div class="info-card">
                    <h4>Adaptive Over Time</h4>
                    <ul>
                        <li>As computers get faster, you can increase the cost factor so that bcrypt remains slow enough to deter attackers.</li>
                        <li>You don't ever need to change your users' stored hashes when you bump the cost—future registrations or password changes will just use the new cost.</li>
                    </ul>
                </div>

                <div class="info-card">
                    <h4>Salt Embedded in the Stored Hash</h4>
                    <ul>
                        <li>A bcrypt "hash string" looks something like:
                            <pre><code class="language-text">$2b$12$e0NRQsHknI9cXK1Jf4ZR6uVjQPfeG2z0nI3IXQvXoR1xjhRdJYGCK</code></pre>
                            <ul>
                                <li><code>$2b$</code> indicates the bcrypt version.</li>
                                <li><code>12$</code> is the cost factor (i.e., 2^12 ≈ 4096 internal iterations).</li>
                                <li>The next 22 characters (e.g., <code>e0NRQsHknI9cXK1Jf4ZR6u</code>) are the base64‐encoded salt.</li>
                                <li>The final 31 characters (<code>VjQPfeG2z0nI3IXQvXoR1xjhRdJYGCK</code>) are the actual bcrypt hash of the password+salt.</li>
                            </ul>
                        </li>
                        <li>When you call <code>bcrypt.compare(plainText, storedHash)</code>, bcrypt reads the salt and cost factor from the stored hash automatically.</li>
                    </ul>
                </div>
            </section>

            <section id="bcrypt-how-works">
                <h3>3. How bcrypt Works (High-Level)</h3>

                <div class="flow-step">
                    <h4>Generate Salt</h4>
                    <ul>
                        <li>You pick a cost factor (say, <code>12</code>).</li>
                        <li>bcrypt internally generates a 128‐bit random salt, encodes it in base64, and prefixes it along with the cost.</li>
                    </ul>
                </div>

                <div class="flow-step">
                    <h4>Hashing Process (Blowfish‐Based)</h4>
                    <ul>
                        <li>bcrypt uses an adapted version of the Blowfish key setup function. It repeatedly mixes the password and the salt through many rounds (2^cost) of computation.</li>
                        <li>This results in a final 192‐bit value, which is then base64‐encoded to form that last part of the hash string.</li>
                    </ul>
                </div>

                <div class="flow-step">
                    <h4>Storing the Result</h4>
                    <ul>
                        <li>You store the entire string—version, cost, salt, and hash—in one field (e.g., <code>passwordHash</code>) in your user table.</li>
                        <li>There's no need to manage salt separately since it's embedded.</li>
                    </ul>
                </div>

                <div class="flow-step">
                    <h4>Verifying a Password</h4>
                    <ul>
                        <li>When a user logs in, you retrieve their stored hash.</li>
                        <li>You call something like <code>bcrypt.compare("user's input", storedHash)</code>.</li>
                        <li>bcrypt reads the salt and cost from <code>storedHash</code> and performs the same key‐derivation function.</li>
                        <li>If the newly computed hash matches the stored one, the password is correct; otherwise, it fails.</li>
                    </ul>
                </div>
            </section>

            <section id="express-workflow">
                <h3>4. Typical Workflow in an Express App</h3>

                <div class="code-section">
                    <h4>Registration (Hashing the Password)</h4>
                    <ul>
                        <li>User submits <code>{ email, password }</code>.</li>
                        <li>You pick a cost factor (e.g., 12) and call:</li>
                    </ul>
                    <pre><code class="language-javascript">const saltRounds = 12;
const passwordHash = await bcrypt.hash(password, saltRounds);</code></pre>
                    <ul>
                        <li>Save <code>email</code> and <code>passwordHash</code> into your database.</li>
                    </ul>
                </div>

                <div class="code-section">
                    <h4>Login (Comparing the Password)</h4>
                    <ul>
                        <li>User submits <code>{ email, password }</code>.</li>
                        <li>Fetch <code>user</code> by email; get <code>storedHash</code> from the DB.</li>
                        <li>Call:</li>
                    </ul>
                    <pre><code class="language-javascript">const isMatch = await bcrypt.compare(password, storedHash);</code></pre>
                    <ul>
                        <li>If <code>isMatch</code> is <code>true</code>, the password is correct—proceed to issue a JWT.</li>
                        <li>If <code>false</code>, respond with "Invalid credentials."</li>
                    </ul>
                </div>
            </section>

            <section id="cost-factor">
                <h3>5. Choosing the Right Cost Factor (Salt Rounds)</h3>
                <ul>
                    <li><strong>Lower Cost</strong> (e.g., 8–10): Faster hashing and comparison, but less resistance to brute force.</li>
                    <li><strong>Higher Cost</strong> (e.g., 12–14+): Much slower (on the order of hundreds of milliseconds per hash), stronger security.</li>
                    <li><strong>Guideline:</strong>
                        <ol>
                            <li>On your production server, run a quick test:
                                <pre><code class="language-javascript">const start = Date.now();
await bcrypt.hash("testPassword", 12);
console.log("Time elapsed:", Date.now() - start, "ms");</code></pre>
                            </li>
                            <li>Aim for somewhere between 100 ms to 300 ms per hash.</li>
                            <li>If it's under 50 ms, increase the cost; if it's over 500 ms, consider lowering it a bit so your login endpoints don't feel sluggish to real users.</li>
                        </ol>
                    </li>
                </ul>
            </section>

            <section id="security-considerations">
                <h3>6. Security Considerations</h3>

                <div class="security-tip">
                    <h4>Never Store Plain‐Text Passwords</h4>
                    <ul>
                        <li>Always call <code>bcrypt.hash()</code> before saving.</li>
                        <li>Even if an attacker gets your DB, they must crack each hash by brute force to find the password.</li>
                    </ul>
                </div>

                <div class="security-tip">
                    <h4>Automatic Salts Prevent Precomputed Tables</h4>
                    <ul>
                        <li>Because each hash has a unique random salt, an attacker can't just compare against a giant rainbow table. They'd need to brute‐force each user's password individually.</li>
                    </ul>
                </div>

                <div class="security-tip">
                    <h4>Beware of Timing Attacks</h4>
                    <ul>
                        <li>bcrypt's <code>compare()</code> is designed to run in constant-ish time regardless of how many characters match, so partial matches don't leak information.</li>
                        <li>Always use <code>bcrypt.compare()</code> rather than trying to roll your own comparison.</li>
                    </ul>
                </div>

                <div class="security-tip">
                    <h4>Upgrade Cost Over Time</h4>
                    <ul>
                        <li>As CPUs become faster, periodically revisit your cost factor.</li>
                        <li>You don't need to re‐hash every existing user's password immediately; you can just use the new cost when they next log in (by detecting <code>bcrypt.getRounds(storedHash) < desiredRounds</code>, re‐hashing on successful login).</li>
                    </ul>
                </div>

                <div class="security-tip">
                    <h4>Limit Login Attempts</h4>
                    <ul>
                        <li>Even with bcrypt, attackers might try brute‐forcing by sending many login attempts.</li>
                        <li>Use rate limiting or account‐lockout strategies (e.g., after 5 failed tries, block for a few minutes).</li>
                    </ul>
                </div>
            </section>

            <section id="bcrypt-analogy">
                <h3>7. Analogy: Padlock With a Variable Complexity</h3>
                <div class="analogy-box">
                    <ul>
                        <li><strong>Imagine</strong> each user's password is locked inside a padlock.</li>
                        <li>That padlock has an internal mechanism whose complexity you can adjust—you can set it to be "3 tumbler pins" or "5 tumbler pins."</li>
                        <li>The more pins, the longer it takes you to pick the lock (analogous to more salt rounds in bcrypt).</li>
                        <li>For each user, you randomly change the internal configuration (the "salt"), so even if two locks hold the same password, their pin arrangements differ.</li>
                        <li>When a user tries to login, you hand them a "key" (their typed password). They try to pick the lock exactly the same way each time.</li>
                        <li>If the key fits and the pins align, the lock opens (bcrypt compare returns true). If not, they're out of luck.</li>
                    </ul>
                </div>
            </section>

            <section id="bcrypt-methods">
                <h3>8. Quick Reference of Common bcrypt Methods</h3>

                <div class="method-card">
                    <h4><code>bcrypt.hash(password, saltRounds) → Promise&lt;string&gt;</code></h4>
                    <ul>
                        <li>Takes a plain‐text password and a cost factor (e.g., 10, 12, 14).</li>
                        <li>Returns a string like <code>$2b$12$wJ7...f5b8</code>.</li>
                    </ul>
                </div>

                <div class="method-card">
                    <h4><code>bcrypt.compare(candidatePassword, storedHash) → Promise&lt;boolean&gt;</code></h4>
                    <ul>
                        <li>Returns <code>true</code> if <code>candidatePassword</code> matches the <code>storedHash</code>, <code>false</code> otherwise.</li>
                        <li>Under the hood, it reads the salt and cost from <code>storedHash</code> and does the work accordingly.</li>
                    </ul>
                </div>

                <div class="method-card">
                    <h4><code>bcrypt.genSalt(saltRounds) → Promise&lt;string&gt;</code> (less common)</h4>
                    <ul>
                        <li>Explicitly generate a salt string first (e.g., <code>$2b$12$wJ7...</code>).</li>
                        <li>Then call <code>bcrypt.hash(password, salt)</code> instead of passing a number.</li>
                        <li>Most libraries let you just pass the number directly; they generate and apply the salt for you.</li>
                    </ul>
                </div>

                <div class="method-card">
                    <h4><code>bcrypt.getRounds(storedHash) → number</code></h4>
                    <ul>
                        <li>Extracts the cost factor (e.g., <code>12</code>) from an existing hash. Useful if you want to detect if an old hash uses fewer rounds than you want now.</li>
                    </ul>
                </div>
            </section>

            <div class="summary-box">
                <h3>In a Nutshell</h3>
                <ul>
                    <li><strong>bcrypt</strong> is a one‐way, salted, adaptive key‐derivation function suited for password storage.</li>
                    <li>It automatically embeds a random salt and a cost factor in each hash.</li>
                    <li>Higher cost (= more salt rounds) means slower hashing, which deters brute‐force attacks.</li>
                    <li>Use <code>bcrypt.hash()</code> to generate a new hash when registering/changing a password.</li>
                    <li>Use <code>bcrypt.compare()</code> to check a candidate password against the stored hash.</li>
                </ul>
            </div>
        </section>

        <div class="divider section-divider"></div>

        <section id="login-functionality">
            <h2>Login Functionality</h2>

            <section id="user-submits">
                <h3>1. Login Functionality</h3>

                <div class="subsection">
                    <h4>1.1. User Submits Credentials</h4>
                    <div class="feature-box">
                        <h5>Client Side</h5>
                        <ul>
                            <li>The user fills out a login form (e.g., email or username plus password).</li>
                            <li>When they hit "Log In," the client (browser, mobile app, etc.) sends those credentials in a POST request to your server, typically to an endpoint like <code>/api/auth/login</code>.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Express Receives the Request</h5>
                        <ul>
                            <li>Express has a route handler for <code>/api/auth/login</code> that receives the request body.</li>
                            <li>The handler first checks that both "email" and "password" fields are present and (optionally) well-formed (e.g., correct email format).</li>
                        </ul>
                    </div>
                </div>

                <div class="subsection">
                    <h4>1.2. Verify User Exists</h4>
                    <div class="feature-box">
                        <h5>Mongoose Query</h5>
                        <ul>
                            <li>Inside that handler, you use your Mongoose User model to look up the account by email (or username).</li>
                            <li>If no matching user record is found, you immediately return a 401 Unauthorized (e.g., "Invalid credentials") because either the email is incorrect or the user doesn't exist.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Password Comparison with bcrypt</h5>
                        <ul>
                            <li>If a user is found, you extract the stored <code>passwordHash</code> from the database.</li>
                            <li>You then call <code>bcrypt.compare(submittedPassword, storedHash)</code>, which internally reads the salt and cost factor from the stored hash, hashes the submitted password the same way, and returns <code>true</code> if they match.</li>
                            <li>If it returns <code>false</code>, you again send a 401 Unauthorized, because the password didn't match.</li>
                        </ul>
                    </div>
                </div>

                <div class="subsection">
                    <h4>1.3. Issue a JWT upon Successful Login</h4>
                    <div class="feature-box">
                        <h5>Building the Payload</h5>
                        <ul>
                            <li>Once bcrypt says "yes, that's the right password," you build a small "payload" object for the JWT. Typically this contains:
                                <ul>
                                    <li>A <strong>subject</strong> (<code>sub</code>) field set to the user's unique ID (e.g., the Mongo-generated <code>_id</code>).</li>
                                    <li>Any additional claims you need—perhaps the user's role (admin, user), an email address, or a "token version" for revocation logic.</li>
                                </ul>
                            </li>
                            <li>You keep this payload minimal to avoid large tokens.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Signing the Token</h5>
                        <ul>
                            <li>Using your <code>jsonwebtoken</code> library, you sign that payload with a secret key (e.g., stored in an environment variable).</li>
                            <li>You also set an <strong>expiration</strong> (for example, 1 hour). That expiration is encoded as the <code>exp</code> claim, so JWT itself knows when it's no longer valid.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Sending the Token to the Client</h5>
                        <ul>
                            <li>The response from the login endpoint is a JSON object like <code>{ token: "&lt;JWT_STRING&gt;" }</code>.</li>
                            <li>The client then stores that token—common approaches include:
                                <ul>
                                    <li><strong>Browser:</strong> Store in an HttpOnly, Secure cookie (so JavaScript can't read it, reducing XSS risk).</li>
                                    <li><strong>Single-Page App (React/Vue):</strong> Store in memory or, less ideally, in <code>localStorage</code> (but you must protect against XSS if you do).</li>
                                    <li><strong>Mobile App:</strong> Store in secure storage/keychain.</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>

                <p>At this point, the "login" is complete: the server has verified the user's credentials and issued a signed token that proves their identity until it expires.</p>
            </section>

            <section id="session-management">
                <h3>2. Session Management with JWT</h3>
                <p>Unlike traditional session-based systems (where you store a session record in the database and keep track of a session ID on the server), using JWT creates a <strong>stateless session</strong>. The token itself carries all the information needed to authenticate the user. Here's how that looks:</p>

                <div class="subsection">
                    <h4>2.1. Stateless "Session" Concept</h4>
                    <div class="feature-box">
                        <h5>No Server-Side Session Store</h5>
                        <ul>
                            <li>Once you hand out a JWT, you don't save anything in memory or in a DB about that session.</li>
                            <li>On every subsequent request to a protected route, the client simply sends back the same token, and the server verifies it on the fly—no need to look up a session record.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Verifying the Token</h5>
                        <ul>
                            <li>You write a middleware (e.g., <code>authMiddleware</code>) that:
                                <ol>
                                    <li>Reads the <code>Authorization: Bearer &lt;token&gt;</code> header.</li>
                                    <li>Calls <code>jwt.verify(token, SECRET_KEY)</code>, which checks the signature and ensures <code>exp</code> hasn't passed.</li>
                                    <li>If valid, it extracts the payload (e.g., <code>{ sub: "607f1f77bcf86cd799439011", role: "user", iat: 162... }</code>) and attaches it to <code>req.user</code>.</li>
                                    <li>If invalid or expired, it sends a 401 Unauthorized.</li>
                                </ol>
                            </li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Using <code>req.user</code> in Route Handlers</h5>
                        <ul>
                            <li>Any protected endpoint sees that <code>req.user.sub</code> is the user's ID. You can now fetch more data (if needed) via Mongoose (e.g., user profile, preferences, etc.).</li>
                            <li>Or, if you embedded roles/permissions inside the JWT, you can even decide an endpoint's authorization purely from <code>req.user.role</code> without hitting the database again.</li>
                        </ul>
                    </div>
                </div>

                <div class="subsection">
                    <h4>2.2. Token Expiration and Refresh</h4>
                    <div class="feature-box">
                        <h5>Short-Lived Tokens</h5>
                        <ul>
                            <li>A best practice is to issue fairly short-lived access tokens (e.g., 15 minutes or 1 hour).</li>
                            <li>That way, if a token is stolen, the attacker's window of opportunity is limited.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Refresh Tokens (Optional Add-On)</h5>
                        <ul>
                            <li>To avoid forcing the user to re-enter credentials every hour, you typically also issue a long-lived <strong>refresh token</strong> at login.</li>
                            <li>The refresh token is:
                                <ul>
                                    <li>Usually stored in a secure, HttpOnly cookie (so JavaScript can't read it).</li>
                                    <li>Tied to a record in your database (or you use a JWT with a "token version" claim that you check on the server).</li>
                                    <li>Sent to a special endpoint like <code>/api/auth/refresh</code>: when the client sees its short-lived access token has expired, it automatically sends the refresh token to get a brand-new access token (and possibly a new refresh token).</li>
                                </ul>
                            </li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Revoking Refresh Tokens</h5>
                        <ul>
                            <li>If a user logs out, changes their password, or you detect suspicious behavior, you can invalidate the refresh token server-side—e.g., by deleting a record in a "refreshTokens" collection or bumping a "tokenVersion" field in the user's document.</li>
                            <li>That way, even if someone holds an old refresh token, the server will reject it and require a fresh login.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Access Token Blacklist (Rarely Used)</h5>
                        <ul>
                            <li>Because JWTs are stateless, you generally don't store or check them in a database. But if you want to immediately invalidate a particular access token before it naturally expires, you'd need a blacklist.</li>
                            <li>Implementing an access-token blacklist often becomes complex and is rarely necessary if your access tokens are short-lived and you rely on refresh tokens for longer sessions.</li>
                        </ul>
                    </div>
                </div>

                <div class="subsection">
                    <h4>2.3. Logging Out</h4>
                    <div class="feature-box">
                        <h5>Client-Side Cleanup</h5>
                        <ul>
                            <li>When a user clicks "Log Out," your front end simply deletes the stored access token (and possibly the refresh token cookie).</li>
                            <li>Without a valid token, any further requests to protected endpoints will fail.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h5>Optional Server-Side Invalidation</h5>
                        <ul>
                            <li>If you're using refresh tokens stored server-side (e.g., in a "refreshTokens" collection keyed by user ID or token ID), you also delete or mark the refresh token as invalid.</li>
                            <li>This ensures that if someone held that refresh token (e.g., a stolen cookie), they can't get a new access token once the old one expires.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="putting-together">
                <h3>3. Putting It All Together</h3>

                <div class="workflow-step">
                    <h4>1. User Logs In</h4>
                    <ul>
                        <li><code>POST /api/auth/login</code> → verify with bcrypt → issue:
                            <ul>
                                <li>A short-lived <strong>access JWT</strong> (e.g., 15 min – 1 h) returned in JSON.</li>
                                <li>A long-lived <strong>refresh token</strong> stored in an HttpOnly cookie (if you want seamless renewals).</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="workflow-step">
                    <h4>2. Client Stores Tokens</h4>
                    <ul>
                        <li>Access token: stored in memory or local storage (but protected).</li>
                        <li>Refresh token: stored as a Secure, HttpOnly cookie so it's sent automatically on a specific route when needed.</li>
                    </ul>
                </div>

                <div class="workflow-step">
                    <h4>3. User Requests Protected Resource</h4>
                    <ul>
                        <li>Client sends <code>Authorization: Bearer &lt;access_token&gt;</code> to endpoints like <code>/api/profile</code>, <code>/api/settings</code>, etc.</li>
                        <li>Middleware does <code>jwt.verify(...)</code>: if valid, attaches <code>req.user</code> and lets the handler run. If not, returns 401.</li>
                    </ul>
                </div>

                <div class="workflow-step">
                    <h4>4. Access Token Expires</h4>
                    <ul>
                        <li>The client sees a 401 with a message like "Token expired."</li>
                        <li>It then calls <code>POST /api/auth/refresh</code> (no JSON body needed; the refresh token cookie is sent automatically).</li>
                        <li>If the refresh token is valid (not expired, not revoked, matches your DB record), you issue a brand-new access token (and maybe a new refresh token) and return it.</li>
                        <li>The client replaces its stored access token and retries the original request.</li>
                    </ul>
                </div>

                <div class="workflow-step">
                    <h4>5. User Logs Out</h4>
                    <ul>
                        <li>Client deletes the access token from memory/storage.</li>
                        <li>Client calls <code>POST /api/auth/logout</code>, which deletes/revokes the refresh token server-side (if you're tracking them).</li>
                        <li>From now on, neither the old access token nor the old refresh token works.</li>
                    </ul>
                </div>
            </section>

            <section id="why-works-well">
                <h3>4. Why This Approach Works Well</h3>

                <div class="benefit-box">
                    <h4>Stateless Scalability:</h4>
                    <p>Because access tokens (JWTs) are self-contained, there's no need to keep a server-side session store or synchronize session data across multiple instances of your backend. Any server can verify a token with just the secret key.</p>
                </div>

                <div class="benefit-box">
                    <h4>Secure Password Storage:</h4>
                    <p>You never store or transmit plain-text passwords. bcrypt ensures that whatever lands in your database is a salted, slow hash that's extremely hard to reverse-engineer.</p>
                </div>

                <div class="benefit-box">
                    <h4>Fine-Grained Control Over Token Lifetimes:</h4>
                    <p>You choose how short or long an access token should live. Short access tokens minimize risk if stolen. The separate refresh token allows you to keep users logged in without frequent full reauthentication.</p>
                </div>

                <div class="benefit-box">
                    <h4>Role-Based or Scope-Based Authorization Built-In:</h4>
                    <p>By including claims like <code>role: "admin"</code> or <code>scope: ["read:messages", "write:profile"]</code> in your JWT payload, downstream services or route handlers can make quick authorization checks without extra database lookups.</p>
                </div>

                <div class="benefit-box">
                    <h4>Easy Logout and Revocation via Refresh Tokens:</h4>
                    <p>While you can't instantly invalidate a JWT (because it's stateless), revoking a refresh token server-side ensures that once the short-lived access token expires, no new access tokens can be minted with that refresh token. Thus, "logout" is effectively enforced on the next token refresh.</p>
                </div>
            </section>

            <div class="summary-box">
                <h3>In a Nutshell</h3>
                <ol>
                    <li><strong>Login:</strong>
                        <ul>
                            <li>Verify email/password with Mongoose + bcrypt.</li>
                            <li>Issue a signed JWT (and optionally a refresh token).</li>
                            <li>Return tokens to the client.</li>
                        </ul>
                    </li>
                    <li><strong>Session ("Stateless") Management:</strong>
                        <ul>
                            <li>Client sends JWT on each request.</li>
                            <li>Middleware verifies JWT, attaches user info to <code>req</code>.</li>
                            <li>When JWT expires, client uses refresh token (if implemented) to get a new access JWT.</li>
                        </ul>
                    </li>
                    <li><strong>Logout:</strong>
                        <ul>
                            <li>Client deletes tokens.</li>
                            <li>Server revokes refresh token so user can't silently get a new access token.</li>
                        </ul>
                    </li>
                </ol>
                <p>By combining Express routes, Mongoose for user lookups, bcrypt for secure password checks, and JWTs for session tokens, you get a robust, scalable login system with clear boundaries between authentication (verifying identity) and authorization (checking roles/permissions) — all without keeping per-user session state on the server.</p>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 User Authentication Documentation</p>
        </div>
    </footer>
</body>
</html>